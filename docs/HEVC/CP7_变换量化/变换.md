# 变换

## 1 简介

### 1.1 概述

HEVC 进行变换操作目的是**去除残差区块的相关性**，最佳去相关的变换是 **KL 变换**（Karhunen–Loeve transform），但 DCT 变换具有**变换形式与输入无关**、**具有快速算法**以及**性能与 KL 变换接近**的特点，因此使用 DCT 变换而不是 KL 变换

### 1.2 变换的种类

HEVC 中使用的变换有 **core 变换**（基于二维 DCT）和 **alternate 变换**（基于二维 DST），其中**大小为 4x4** 的**帧内预测**的 TU 区块使用 alternate 变换，其余 TU 使用 core 变换

## 2 DCT

### 2.1 DCT 与 DFT

DCT 是 HEVC 变换量化中所采用的主要变换方法，其本质是一种**特殊的 DFT 运算**，DCT 有很多种（详见[维基百科](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2)），我们通常使用的 DCT 是其中的**第二种**

DCT 的正变换公式如下

$$ X[k]=\sum_{n=0}^{N-1} \sqrt{\frac{2}{N}}x[n]cos[\frac{\pi}{N}(n+\frac{1}{2})k]$$

DFT 的正变换公式如下

$$X[k]=\sum_{n=0}^{N-1}x[n]cos(\frac{2\pi nk}{N})-j\sum_{n=0}^{N-1}x[n]sin(\frac{2\pi nk}{N})$$

从 DFT 到 DCT 主要经过了以下三步变化

1. 虚部消失：通过强制使 DFT 输入序列 $x[n]$ 为**实偶函数**，可以使得其 DFT 运算结果也为实偶函数，**虚部为零**
2. $2\pi nk$ 变为 $\pi(n+\frac{1}{2})k$：强制 DFT 输入序列为实偶函数的方法是将输入序列 $\bf x[n]$ 做偶对称然后左移 $\bf \frac{1}{2}$（如下图），做偶对称使得算式中的累和由 N 项变为 2N 项，cos 函数的参数中的 $\frac{1}{N}$ 变为 $\frac{1}{2N}$，抵消掉了 $2\pi nk$ 中的 2，左移使得 $n$ 变为 $n+\frac{1}{2}$ 

    偶对称图示（图片截自下文中的链接）

    ![变换_2804329472](markdown_images/%E5%8F%98%E6%8D%A2_2804329472.png)

    移位图示

    ![变换_7278066688](markdown_images/%E5%8F%98%E6%8D%A2_7278066688.png)

3. 多了一个 $\sqrt{\frac{2}{N}}$，这个主要用于使矩阵正交

因此，**DCT 等于先把输入序列 $\bf x[n]$ 做偶对称然后移位 $\bf \frac{1}{2}$ 再做 DFT**

关于上述关系的进一步解释见[此知乎文章](https://zhuanlan.zhihu.com/p/85299446)

二维 DCT 的正变换与逆变换如下图

![变换_7377198080](markdown_images/%E5%8F%98%E6%8D%A2_7377198080.png)

### 2.2 DCT 的系数矩阵

关于 **DCT/IDCT 系数矩阵**的介绍如下图（图片截自[此网站](http://blog.sina.com.cn/s/blog_7445c2940102wcdl.html)，其一行为一个**基向量**）

![变换_4465766400](markdown_images/%E5%8F%98%E6%8D%A2_4465766400.png)

通过此矩阵可以方便的进行**一维 DCT 变换**，令输入**列向量**为 $\bf x$，系数矩阵为 $\bf C$，则一维 DCT 变换为 $\bf Cx$，令输入**矩阵**为 $\bf X$，则对这个矩阵**按列**进行一维 DCT 变换的结果为 $\bf CX$

二维 DCT 具有**可分离性**，对矩阵 $\bf X$ 进行二维 DCT 变换等价于**先对这个矩阵按行做 DCT，然后再对 DCT 的结果按列做 DCT**（先列再行也行），按行做 DCT 可以等价于先对 $\bf X$ 转置然后按列做 DCT 然后再转置回来，即 $\bf (CX^T)^T=XC^T$，因此整个二维 DCT 过程可以表示为 $\bf CXC^T$，IDCT 使用的系数矩阵为 DCT 系数矩阵的转置，因此二维 IDCT 过程可以表示为 $\bf C^TXC$

在变换操作中，$\bf C$ 以**整数 DCT 矩阵**替代

### 2.3 整数 DCT 系数矩阵

整数 DCT 系数矩阵是**将上述矩阵 $\bf C$ 每个系数乘以 $\bf 2^{6+M/2}$ 然后手动舍入**（hand tune）之后的结果，手动舍入的目的是**保证整数 DCT 系数矩阵保留原 DCT 矩阵的一些重要性质**，比如偶数行对称奇数行不对称、$2^M\times2^M$ 大小的 DCT 变换系数矩阵是 $2^{M+1}\times2^{M+1}$ 大小的 DCT 变换系数矩阵的一个采样（后者偶数行（行号从 0 开始）的前一半元素）以及 $2^M\times2^M$ 大小的变换系数矩阵只有 $2^M-1$ 个不同的元素

以下为不同大小的 DCT 系数矩阵

- 4x4（4x4 是 8x8 的第 0 2 4 6 行的前 4 个元素，是 16x16 的 0 4 8 12 行的前 4 个元素）

    ![变换_3758288896](markdown_images/%E5%8F%98%E6%8D%A2_3758288896.png)

- 8x8（8x8 是 16x16 的第 0 2 4 6 8 10 12 14 行的前 8 个元素）

    ![变换_8299197440](markdown_images/%E5%8F%98%E6%8D%A2_8299197440.png)

- 16x16

    ![变换_5154615296](markdown_images/%E5%8F%98%E6%8D%A2_5154615296.png)

完整的正向变换的整数 DCT 系数矩阵（左半部分，右边可通过对称性得到）见**英文书**（High Efficiency Video Coding (HEVC): Algorithms and Architectures）**P149**，矩阵**第 0 列第 1-end 个元素是其 $\bf 2^M-1$ 个独特元素**（虽然 32x32 矩阵开头有 3 个 90，但是那个是意外——英文书） 

## 3 蝶式算法

### 3.1 简介

蝶式算法是 DCT 矩阵运算的加速算法，可以有效减少矩阵运算所需的加法和乘法操作。

具有奇偶间隔对称性（一行奇对称，一行偶对称）的矩阵能够使用单次蝶式运算加速，具有递归式对称性（也就是按照蝶式算法规则划分的奇偶部分依旧满足奇偶间隔对称性）的矩阵能够使用多次蝶式运算加速。

### 3.2 基本过程

DCT 系数矩阵 C 具有特殊性质，偶数行偶对称，奇数行奇对称，下图为 4x4 的整数矩阵**转置**，$d_{16},\ d_{24},\ d_{8}$ 为该矩阵的独特元素（具体解释 $d_i$ 为英文书 P149 页矩阵第零列的第 i 个值）。具有这样特色的矩阵可以按照下图分成 even part 和 odd part（偶行前一半，奇行后一半，这里是转置，按列分），even part 和 odd part 可以先和对应的列向量 $x_0,x_2\ or\ x_1,x_3$ 算出一个乘积和中间值 $z_0,z_1\ or\ z_2,z_3$，这个是下图中左下侧示意图的实线部分，表示实线部分的元素与列向量的乘积和，然后**根据对称性无需计算你就能够得到虚线部分的结果**，这是这一行剩下的元素与列向量的乘积和，实线部分的和加上虚线部分的和就是这一行与列向量的乘积和（最终结果），所以算出实线部分之后，你**只需要四个加法**（图右下）就能结束这次矩阵乘积的运算，**啪的一下，很快啊**

![变换_2872623104](markdown_images/%E5%8F%98%E6%8D%A2_2872623104.png)

以上为单次蝶式运算的步骤，**任何具有奇偶间隔对称性（一行奇对称，一行偶对称）的矩阵都能够使用单次蝶式运算加速**

对于 8x8 矩阵，可以同样以如下方式进行奇偶分解（这个矩阵没转置）

![变换_3549491200](markdown_images/%E5%8F%98%E6%8D%A2_3549491200.png)

首先如上图分成 even part 和 odd part，这步可以称之为**接**，把奇偶部分给**接出来**，然后算出 even part 和 odd part 的 z 值结果，这步称为**化**，通过~~**化劲**~~**对称性**直接得到另一半结果，最后 8 个加法**突然发力，瞬间结束运算**，令人措手不及，称为**发**，由上**接化发**三步，便可快速完成以上矩阵的蝶式运算。但蝶式算法的奥妙不在于此，只要你**接得巧**，接出来的矩阵依旧是符合奇偶对称，那么在你**化的时候又可以跟一套接化发**，如上图，对 even part 可以再进行一套蝶式运算进行加速，而 odd part 则不满足要求，只能进行普通的矩阵运算。**因此当你打出一个接化发的时候，实际上你打出的是一连串的接化发，这才是混元太极的精华所在。**

显然，作为掌门人，马大师在使用接化发的时候，只是演示的目的，**传统功夫点到为止**，因此只使用了一次的接化发，并没有在接的时候用巧劲从而得以使出一连串的接化发，这样才会被小年轻偷袭，否则的话，他可以**减少约一半的计算**，瞬间结束战斗。所以请大家不要耍小聪明，**耗子尾汁，好好反思**

以上为递归式进行蝶式运算的步骤，**任何具有递归式对称性（也就是按照蝶式划分的奇偶部分依旧满足奇偶间隔对称性）的矩阵能够使用多次蝶式运算加速**

### 3.3 复杂度分析

1D 的 IDCT 变换需要 $N^2$ 的乘法操作和 $N(N-1)$ 的加法操作，2D 的 IDCT 变换需要 $2N^3$ 的乘法操作和 $2N^2(N-1)$ 的加法操作

对于上图中 4x4 矩阵的情况，如果马大师直接计算，需要 16 次乘法和 12 次加法，采用~~接化发~~蝶式算法计算，只需要先采用 8 次乘法（英文书上是 6 次，因为考虑了重复）和 4 次加法算出 z0 z1 和 z2 z3，然后再用 4 次加法就能得到结果，**节省了 50% 的乘法和 33% 的加法**

对于上图中 8x8 矩阵的情况，如果直接计算，需要 64 次乘法和 56 次加法，采用蝶式算法计算，计算 even part 需要 8 次乘法和 8 次加法，计算 odd part 需要 16 次乘法和 12 次加法，最后 add/sub 需要 8 次加法，一共需要 24 次乘法（英文书上是 22 次）和 28 次加法，**节省了 62.5% 的乘法和 50% 的加法**

## 4 DST

### 4.1 整数 DST 系数矩阵

4x4 的 intra TU 使用的整数 DST 系数矩阵如下

![变换_249623552](markdown_images/%E5%8F%98%E6%8D%A2_249623552.png)

此矩阵元素通过以下公式获取

![变换_308362240](markdown_images/%E5%8F%98%E6%8D%A2_308362240.png)