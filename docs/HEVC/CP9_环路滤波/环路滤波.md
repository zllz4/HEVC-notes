# 环路滤波

## 1. 概要

在H.264中环路滤波只有**去块滤波**（deblocking in-loop filter）一种，而在HEVC中有两种环路滤波：去块滤波（deblocking filter）和**样本自适应偏置**（sample adaptive offset, SAO）。SAO在去块滤波之后，能一定程度上减少重构图像的振铃效应。HEVC 因此能提高解码视频序列的主观质量以及重建/参考图像的压缩效率。

接下来主要介绍 H.264 中的去块滤波。

## 2. 设计思路

### 2.1 块效应

**块效应（blocking artifact）：**观看视频时，在剧烈运动的长经常能观察到图像出现小方块，小方块在边界处表现出明显的不连续性，这种现象称为块效应。

H.264在编码的过程中对像素残差进行DCT变换，变换后得到的DCT系数代表了被变换数据的基础色调与细节。H.264在DCT变换后对DCT系数进行了**量化**，量化能有效去除相邻像素加的空间冗余，但同时也抹去了数据的部分细节。在**低码率情况**下会导致原始数据细节丢失过多。由于DCT变换是**基于块**的，如果进行了低码率的量化，就会使得相邻两个块的相关性变差，从而出现块效应。

H.264的**运动补偿**会加剧有变换量化导致的块效应。由于运动补偿的匹配是有损的，各个块的残差大小存在差异，当相邻块多用参考帧不同、运动矢量或参考块的差距过大时，块边界上的不连续越发明显。

块效应主要有两种：一种是由于DCT高频系数被量化为0，使得强边缘在跨边界处出现锯齿状，称为**梯形噪声**；另一种常出现在平坦区域，由于量化导致平缓变换的亮度块DCT系数发生跳跃，造成变换块基础色调改变，称为**格形噪声**。

### 2.2 去块滤波作用及所在位置

去块滤波就是为了减轻和消除视频图像中的块效应，对块边界处的像素进行滤波以平滑像素值的突变。环路滤波位于编码器预测环路中反变换和反量化之后，生成重建的运动补偿的参考帧。因而去块滤波属于预测环路的一部分，属于**环内处理**，而不是环外的后处理。环路滤波的目标就是消除编码过程中由于预测、变换、量化过程中引入的失真。

在编码器中，滤波后的图像会作为后序编码运动补偿的参考图像。

在解码器中，滤波后的图像会被输出显示，并且作为后序图像解码重建的参考图像。

## 3. 关键算法

### 3.1 滤波前准备

#### 3.1.1 滤波参数

在标准中，去块滤波会被应用于亮度以及色度宏块的滤波，语法元素**disable_deblocking_filter_idc**用于控制去块滤波是否打开，它的取值有三个：0、1、2。

- 0：开启去块滤波功能，去块滤波能穿越slice边界。
- 1：关闭去块滤波功能。
- 2：开启去块滤波功能，但是滤波只能对同一个slice范围内的宏块执行。

#### 3.1.2 滤波边界

去块滤波基于宏块进行，包括亮度宏块以及色度宏块。亮度宏块的宽高为16x16宏块，而色度宏块有几种不同的格式，去块滤波边界如下图：



![环路滤波_36768](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_36768.png)

图中粗线条为滤波边界，其中红色粗线为**水平边界（Horizontal edge）**，蓝色粗线为**垂直边界（Vertical edge）**，滤波边界把宏块分割成多个4x4的块。需要注意的一点是，如果transform_8x8_mode_flag为1，则代表亮度宏块以及4:4:4的色度宏块会采用8x8的DCT，此时亮度宏块以及4:4:4的色度宏块的滤波边界会把宏块分割成8x8的块。

滤波边界还能根据滤波过程是否会用到当前宏块以外宏块来进行**细分**。宏块的顶部边界、左边界由于处于宏块边缘，滤波的时候肯定需要用到相邻宏块，而其余的滤波边界在滤波时只会用到当前宏块内部的像素。

![环路滤波_41312](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_41312.png)

滤波**先进行亮度宏块滤波后进行色度宏块滤波**，对一个宏块滤波边界的滤波也需要遵循一定顺序

- 先进行垂直边界滤波，从左到右
- 后进行水平边界滤波，从上到下

#### 3.1.3 滤波源像素定位

去块滤波所用的源像素分布在边界的两边，分别有4个像素点，如下图所示：

![环路滤波_28320](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_28320.png)

p与q像素所在的4x4或者8x8块我们分别成之为P块与Q块。

如果当前编码的图像以帧或者场的方式进行编码，则可以直接按照上述边界两边的位置得到滤波的源像素点。不过如果图像采用帧场自适应方式进行编码**（MBAFF）**，则需要对边界两边的像素进行定位以得到正确的源像素。

由于块效应是由于对块（block）进行DCT变换量化产生的，去块滤波的目的是消除块效应，因此去块滤波需要**正确地定位出进行DCT变换量化的块**。在帧场自适应的编码环境下，宏块可以以帧或者场的方式进行编码，但是在宏块进行重建后得到的都是帧宏块，因此我们需要根据实际情况定位出当时进行DCT变换量化的块所在的像素。

### 3.2 滤波过程

#### 3.2.1 边界强度估算

对于滤波边界，我们首先需要根据边界所在的位置已以及宏块的信息来粗略地估计边界两边的像素差距，我们称这个像素差距为**边界强度**（BS，Boundary Strength）。

![环路滤波_92000](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_92000.png)

上述表格用于亮度BS的计算，色度宏块的BS沿用其相应亮度宏块的BS。

#### 3.2.2 区分真假边界

在粗略地估算滤波边界强度后，我们需要区分这个边界强度是由于对块进行DCT变换量化引起的块效应**（虚假边界）**还是视频图像原有的边界**（真实边界）**。如果是真实边界则不需要进行滤波，如果是虚假边界则需要进行去块滤波。区分真假边界基于下面两个**假设**：

- 真实边界两边像素点的差值通常比虚假边界两边像素值要大
- 对于两边像素值差别很小的真实边界，即使使用了去块滤波，对它的主观效果不会有太大影响

因此，去块滤波应该遵循以下**原则**：

- 在平坦区域，即使很小的像素不连续也很容易被人察觉，所以要使用比较强的去块滤波，可以改变较多的像素点
- 对于复杂的区域，为了保持图像细节，要使用较弱的去块滤波，改变较少的像素点

像素差值是否够大将通过**阈值**来判断。

标准H.264中设定了两个阈值α和β来判断真假边界，**α**表示块与块之间的边界阈值，**β**表示块内部边界的阈值。对于边界两边的像素点的差值，如果下面**三个条件都满足**就会被判定为需要滤波的虚假边界，否则就判定为不需要滤波真实边界。

1. |p0 - q0| < α [IndexA]

2. |p1 - p0| < β [IndexB]

3. |q1 - q0| < β [IndexB]

其中α与β可以通过IndexA以及IndexB从表格中得到。**IndexA**以及**IndxeB**为表格的索引，他们的计算方法如下：

IndexA = Clip3( 0, 51, QPaverage + FilterOffsetA )

IndexB = Clip3( 0, 51, QPaverage + FilterQffsetB )

其中**QPaverage** = ( QPp+QPq+1) / 2，**FilterOffsetA**以及**FilterOffsetB**则为偏移量，偏移量用于调整滤波强度。当需要**增加滤波强度**时，用正偏移量，可以去除由次优运动估计、编码模式选择不当引起的块效应，改善图像主观质量；当需要**减少滤波强度**时，用负的偏移量，可以保护图像细节不被滤波器的平滑作用模糊掉。偏移量将在slice头信息中传输，请参考H.264语法结构中的deblocking相关语法元素。

由上述式子知道，α与β的取决于QP的大小。

可见QP越大（Index越大），α与β就越大。QP越大意味着量化误差越大，块效应会越明显，因此阈值也应该取较大值来增大滤波效果，反之阈值应该取较小值。

#### 3.2.3 滤波运算

在前面我们讨论了5种边界强度BS，当边界强度不为0时，就需要进行边界滤波。h.264的边界滤波有两种滤波器

- BS = 1,2,3，采用强度较弱的滤波器，首先改变p0、q0两个像素点，接着用阈值β判断是否需要调整p1和q1
- BS = 4，此时有两种强度的滤波器，强滤波器可以改变6个像素点（p0、p1、p2、q0、q1、q2），弱滤波器只改变边界上的两个点（p0、q0）

##### 1） BS = 1,2,3时的滤波运算

**①** 首先对边界上的两个像素点**p0与q0**进行滤波，它需要输入p1、p0、q0、q1，滤波过程如下：

![环路滤波_4512](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_4512.png)

1. 先要得到差值Δ，差值的计算方式：Δ = ( (q0-p0)<<2 + (p1-q1) + 4 ) >> 3
2. 然后需要对差值Δ进行限幅，保证这个差值在一定的范围内，这个范围主要通过查表得到，详情请查看标准8.7.2.3
3. 用差值Δ来计算新的p0、q0，也就是滤波后的值

**②** 接下来对块内的像素点**p1与q1**分别进行滤波。4:2:0以及4:2:2色度宏块边界的话是不需要执行这部分的滤波的。如果是要计算p1，则需要输入p2、p1、p0、q0；如果是q1，则需要输入p0、q0、q1、q2。

另外，只有满足|p2-p0|< β才能对p1进行滤波，因为满足这个条件则认为P块内部p1处有**虚假边界**，**p1的滤波过程**如下：

![环路滤波_29792](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_29792.png)

1. 先要得到差值Δ，差值的计算方式为：Δ = ( p2 + ((p0+q0+1)>>1) − (p1<<1)) >> 1
2. 然后需要对差值Δ进行限幅，保证这个差值在一定范围内，这个范围主要通过查表得到，详情请查看标准8.7.2.3
3. 用差值来计算新的p1

q1的滤波过程也是类似的步骤。

##### 2）BS = 4时的滤波运算

在H.264的帧内预测编码中，倾向于对纹理简单的区域用16x16亮度预测模式编码（如蓝天、白色墙面等），以达到快速编码的目的。虽然这种方法只会在宏块边界引起轻微的块效应，但是在这种情况下，即使很小的强度值查表也会在视觉上产生陡峭的阶梯状的感觉（色块分层），因而对于这种**内容平滑**的宏块边界就需要采用**较强的滤波器**；如果此时宏块边界有大量的细节存在，反而不应做强滤波。对此H.264仍采用阈值法来判断是否存在真实边界，如果不存在**大量细节信息**，可以做强滤波，反之做**弱滤波**。

这里的滤波是比较好理解的**抽头滤波器**，P、Q块上的滤波过程差不多，这里以P块为例。

对于P块的点，如果满足下式，则认为细节信息不多：

![环路滤波_39072](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_39072.png)

即内容平滑，故采用**强滤波**：

![环路滤波_39072](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_60576.png)

否则表明细节信息较多，则采用**弱滤波**，只改变p0点：

![环路滤波_39072](markdown_images/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2_51680.png)

## 4. 参考资料

https://www.cnblogs.com/TaigaCon/p/5500110.html

https://www.matools.com/blog/190417151

High Efficiency Video Coding (HEVC): Algorithms and Architectures





