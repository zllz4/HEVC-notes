# 最佳预测模式搜索

通过**计算率失真**选择最佳的预测模式，对于亮度 PB 区块，如果其大小为 4x4 或者 8x8（帧内预测 PU 是不能选择那些花里胡哨的划分方式的），那么只对 35 种预测模式其中的 **8 种预测模式**计算**完整的率失真**（full RDO），对于其它大小的 PU，只对 **3 种预测模式**计算完整的率失真，对于色度 PB 区块，**对 5 种预测模式均计算完整的率失真**

> 完整的率失真采用第三次重建图像与原图像的差计算 SATD，加上编码参数使用的码流长度，而不完整的率失真只用第一次重建图像与原图像的差计算 SATD 且只有这个 SATD，亮度编码使用不完整的率失真选出 8 个计算完整的率失真的候选？

**`TEncSearch::estIntraPredChromaQT`** 函数包含了一个率失真的计算示例

```cpp
// 获得重建图像失真度（the resulting distortion）
xRecurIntraChromaCodingQT  ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
// 获得相关参数编码码流长度（the number of required bits）
UInt uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
// 计算率失真
Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );
```

### 色度 PB 区块

搜寻色度 PB 区块最佳预测模式的函数为 **`EncSearch::estIntraPredChromaQT`** 函数，其大致逻辑如下

```cpp
// 获取 uiModeList
pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
{
	...
	// 编码
	pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
	// 帧内预测
	xRecurIntraChromaCodingQT  ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
	...
	// 计算率失真
	Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );
	// 比较结果
  if( dCost < dBestCost )
  {
    dBestCost   = dCost;
    uiBestDist  = uiDist;
    uiBestMode  = uiModeList[uiMode];
		...
  }
}

// 设置 uiBestMode 为选择的色度预测模式
pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
```

这里有个很严重的问题，就是**它并没有对 34 模式进行特殊处理**，比如跳过什么的，在这里会遍历所有 uiModeList 里的值，如果其中有值被替换成了 34，那么它会真的被当作亮度预测的 34 模式（Ver+32 模式）被进行率失真测试，如果这个 34 模式罕见地比其它模式率失真更低，那么不是这个 34 模式就会被编码成最佳模式了？本来应该编码 DM_CHROMA_IDX 模式的，但是被编码成了 34 模式。。。