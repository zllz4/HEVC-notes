# 量化

### 量化

实际上之前的很多舍入操作也是量化，只不过量化步长是 1，这里的量化与舍入的量化的区别可能就是量化的步长会大于 1，最大是 \\( 2^{47/6}\approx228 \\) ？（QP 再加 1 量化步长就变 256 了）

相关参数：\\( QP \\) 以及 \\( Q_{step} \\)

- HEVC 的量化操作有两个参数，一个是 \\( QP \\)，一个是 \\( Q_{step} \\)，\\( **QP \\)  决定 \\( Q_{step} \\)**，\\( **Q_{step} \\) 用于最终量化操作**
- 量化操作的过程就是原数值除以 \\( Q_{step} \\) 然后进行四舍五入，反量化就是解码得到的值乘以 \\( Q_{step} \\)
- \\( QP \\) 的**取值范围是 0~51**（对于 8bit 输入的情况）
- \\( QP \\) 每增加 6 则 \\( Q_{step} \\) 提高一倍

    ![5_3_量化_0](<markdown_images/5_3_量化_0.png>)

    实际上似乎是这么搞的，但是在程序里面好像没找到 g 这个数组

    ![5_3_量化_1](<markdown_images/5_3_量化_1.png>)

    ![5_3_量化_2](<markdown_images/5_3_量化_2.png>)

    ![5_3_量化_3](<markdown_images/5_3_量化_3.png>)

- \\( QP \\) 使用**预测编码**，传输的是 \\( \Delta QP \\)，\\( QP \\)  的预测值为左侧、上侧和之前（previous）区块的 QP 值的结合

三种与变换和量化有关的**特殊模式**：**I_PCM 模式**、**lossless 模式**、**transform skip 模式**

与频率有关的量化操作（requency-dependent quantization）：对 DCT 变换后得到的系数矩阵的不同位置给予不同的量化参数，量化参数组成量化矩阵（详情见补充）

- 示意图如下（注意这里有 **\\( \bf coeff_Q \\) 的公式**和 \\( **\bf level \\) 的公式**）

    ![5_3_量化_4](<markdown_images/5_3_量化_4.png>)

    注意 shift1 **不是** \\( S_{IT1} \\)！

    shift1 的获取方法如下

    ![5_3_量化_5](<markdown_images/5_3_量化_5.png>)

    注意如式 6.10 的量化操作**只是一种选择**，HEVC 没有规定量化操作，HM 模型就采用了一个**基于率失真优化**（rate-distortion optimized quantization (RDOQ)）**的量化策略**

    为啥要乘起来是 1 啊？正向变换的时候不是有一个缩放系数 \\( 2^{15-B-M} \\) 吗？你后面乘起来是 1 了那么这个缩放系数不就没法抵消了？

    哦好像是因为它正向变换也又乘了一个缩放系数把这个弄没了

    总之，**变换操作会放大，然后要乘以一个变换操作的缩放系数，量化操作也会放大，所以还要乘以一个量化操作的缩放系数**

    \\( f_i \\) 是**量化操作缩放因子**（quantizer multipliers），\\( g_i \\) 是**反量化操作缩放因子**（dequantizer multipliers），两者的作用是**对原数据进行量化等于乘以缩放因子然后移位 \\( \bf Qp/6 \\)**

    ![5_3_量化_6](<markdown_images/5_3_量化_6.png>)

![5_3_量化_7](<markdown_images/5_3_量化_7.png>)